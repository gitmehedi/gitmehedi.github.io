<!DOCTYPE html>
<html lang="en">
<head>
    <title>swapon - Certified Kubernetes Administrator Questions</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Xiaoying Riley at 3rd Wave Media">
    <link rel="apple-touch-icon" sizes="57x57" href="../assets/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="../assets/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="../assets/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="../assets/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="../assets/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="../assets/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="../assets/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="../assets/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="../assets/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="../assets/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/favicon/favicon-16x16.png">
    <link rel="manifest" href="../assets/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

    <script defer src="../assets/fontawesome/js/all.min.js"></script>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/monokai-sublime.min.css">
    <link id="theme-style" rel="stylesheet" href="../assets/css/theme-1.css">
</head>


</head>

<body>


<header class="header text-center" style="">
    <nav class="navbar navbar-expand-lg navbar-dark">

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navigation"
                aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div id="navigation" class="collapse navbar-collapse flex-column">
            <div class="profile-section pt-3 pt-lg-0">
                <img class="profile-image mb-3 rounded-circle mx-auto" src="../assets/images/profile.jpg" alt="image">
                <h1 class="blog-name pt-lg-4 mb-0" style="margin-top: 0px;"><a href="index.html">Mehedi Hasan</a></h1>
                <h3 class="bio mb-3">DevOps, Python, Odoo, Docker, Kubernetes
                </h3>
                <ul class="social-list list-inline py-3 mx-auto">
                    <li class="list-inline-item"><a target="_blank" href="https://www.linkedin.com/in/nopaws/"><i
                            class="fab fa-linkedin-in fa-fw"></i></a></li>
                    <li class="list-inline-item"><a target="_blank" href="https://github.com/gitmehedi"><i
                            class="fab fa-github-alt fa-fw"></i></a></li>
                    <li class="list-inline-item"><a target="_blank" href="https://stackoverflow.com/cv/mdmehedi"><i
                            class="fab fa-stack-overflow fa-fw"></i></a></li>
                </ul>
                <hr>
            </div>

            <ul class="navbar-nav flex-column text-left">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html"><i class="fas fa-home fa-fw mr-2"></i>Home</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../about.html"><i class="fas fa-user fa-fw mr-2"></i>About Me</a>
                </li>
            </ul>
        </div>
    </nav>
</header>

<div class="main-wrapper">
    <article class="blog-post px-3 py-5 p-md-5">
        <div class="container">
            <header class="blog-post-header">
                <h2 class="title mb-2">Certified Kubernetes Administrator (CKA) Questions</h2>
                <div class="meta mb-3">
                    <span class="date">Published on July 24, 2020</span>
                    <span class="time">5 min read</span>
                </div>
            </header>


            <div class="blog-post-body">
                <h2>Questions Sets</h2>
                <ul>
                    <li><a href="#question-1">Questions Set 1</a></li>
                    <li><a href="#question-2">Questions Set 2</a></li>
                    <li><a href="#question-3">Questions Set 3</a></li>
                    <li><a href="#question-4">Questions Set 4</a></li>
                    <li><a href="#question-5">Questions Set 5</a></li>
                </ul>
                <div id="question-1">
                    <h4 style="color: green;">Question Set 1: </h4>
                    <strong>Q1. Bootstrap a Kubernetes v1.10 cluster using kubeadm</strong>
                    <p>You need to bootstrap a Kubernetes v1.10 cluster with one master and one worker node using
                        kubeadm.</p>
                    <strong>Q2. Enable cluster auditing</strong>
                    <ol>
                        <li>Enable cluster wide auditing. You can use the audit policy provided <a
                                href="https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/audit/audit-policy.yaml">here.</a>
                        </li>
                        <li>Make sure the audit logs are properly generated and saved to a log file.</li>
                    </ol>
                    <strong>Q3. Create a deployment running nginx version 1.12.2 that will run in 2 pods</strong>
                    <ol>
                        <li>Scale this to 4 pods.</li>
                        <li>Scale it back to 2 pods.</li>
                        <li>Upgrade nginx version to 1.13.8</li>
                        <li>Check the status of the upgrade</li>
                        <li>How do you do this in a way that you can see history of what happened?</li>
                        <li>Undo the upgrade</li>
                    </ol>
                    <pre><code>
-- create a deployment with image nginx with version 1.12.2 with pods
$ kc deploy nginx --image=nginx:1.12.2 --dry-run=client -o yaml > deploy-nginx.yaml

-- modify replicas to 2 in deploy-nginx.yaml file and run file deploy-nginx.yaml
$ kc -f deploy-nginx.yaml

-- scale nginx deploy to 4
$ k scale deploy nginx --replicas=4 --record=true

-- scale nginx deploy back to 2
$ k scale deploy nginx --replicas=2 --record=true

-- upgrade nginx version to 1.13.8
$  k set image deploy nginx nginx=nginx:1.13.8 --record=true

-- How do you do this in a way that you can see history of what happened?
$  k rollout history deploy nginx

-- Undo the upgrade
$  k rollout undo deploy nginx
                    </code></pre>
                    <strong>Q4. Create a service that uses a scratch disk</strong>
                    <ol>
                        <li>Change the service to mount a disk from the host.</li>
                        <li>Change the service to mount a persistent volume.</li>
                    </ol>
                    <strong>Q5. Create a pod with a Liveness and Readiness probes</strong>
                    <p>
                        You need to create a pod called <b>upNready</b> that has liveness and readiness probes
                        configured for it. Feel free to choose any application of your choice for the pod.
                    </p>
                    <pre>
                        <code>
-- create a pod with name upnready
$ krd upnready --image=nginx > livred-nginx.yaml

-- add livenessProbe and readinessProbe properties in livred-nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: upnready
  name: upnready
spec:
  containers:
  - image: nginx
    name: upnready
    resources: {}
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
    readinessProbe:
       httpGet:
         path: /healthz
         port: 8080

  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
                        </code>
</pre>
                    <strong>Q6. Create a daemon set</strong>
                    <p>
                        Create a daemon set and change the update strategy to do a rolling update with a delay of 30
                        seconds
                        between each update.
                    </p>
                    <pre><code>
-- update strategy with rolling update and terminationGracePeriodSeconds is 30
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd-elasticsearch
  namespace: kube-system
  labels:
    k8s-app: fluentd-logging
spec:
  selector:
    matchLabels:
      name: fluentd-elasticsearch
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
  template:
    metadata:
      labels:
        name: fluentd-elasticsearch
    spec:
      tolerations:
      - key: node-role.kubernetes.io/master
        effect: NoSchedule
      containers:
      - name: fluentd-elasticsearch
        image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
      terminationGracePeriodSeconds: 30
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
                    </code></pre>
                    <strong>Q7. Create a busybox pod</strong>
                    <p>
                        Create a busybox pod without using a manifest and then edit the manifest as per your liking.
                    </p>
                    <pre><code>
-- create a pod with image busybox with command sleep after 600 seconds
$ kubectl run busy-pod --image=busybox --command sleep 600
                    </code></pre>
                    <strong>Q8. Create a pod that uses secrets</strong>
                    <ol>
                        <li>Pull secrets from environment variables.</li>
                        <li>Pull secrets from a volume.</li>
                        <li>Dump the secrets out via kubectl to show it worked.</li>
                    </ol>
                    <pre>
                        <code>
-- create a secret with name colors with a secret key APP_COLOR=RED and DB_NAME=postgres
$ kubectl create secret generic colors --from-literal=APP_COLOR=RED --from-literal=DB_NAME=postgres

-- pull secret in pod using environment variable. create a pod using imperative command and add envti
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: busy-env
  name: busy-env
spec:
  containers:
  - env:
    - name: APP_COLOR
      valueFrom:
        secretKeyRef:
           name: colors
           key: APP_COLOR
    image: nginx
    name: busy-env
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
-- pull secrets from a volume
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: busy-env
  name: busy-env
spec:
  containers:
  - image: nginx
    name: busy-env
    resources: {}
    volumeMounts:
    - name: app-secret
      mountPath: /secret
  dnsPolicy: ClusterFirst
  restartPolicy: Always
  volumes:
  - name: app-secret
    secret:
       secretName: colors
status: {}
                        </code>
                    </pre>
                    <strong>Q9. Create a scheduled Job</strong>
                    <p>
                        Create a job that runs every 3 minutes and prints out the current time.
                    </p>
                    <pre><code>Not in Syllabus</code></pre>
                    <strong>Q10. Create a parallel Job</strong>
                    <p>
                        Create a job that runs 80 times, with 5 containers at a time, and prints "Hello parallel world".
                    </p>
                    <pre><code>Not in Syllabus</code></pre>
                    <strong>Q11. Create a service </strong>
                    <p>
                        Create a service that uses an external load balancer and points to a 3 pod cluster running
                        nginx.
                    </p>
                    <pre><code>
                        # Create a 3 pod deployment of nginx in a file
                        $ kubectl create  deploy lb-nginx --image nginx --dry-run -o yaml > lb-nginx.yaml

                        # Scale deployment to 3 replicas
                        $ kubectl scale deploy lb-nginx --replicas=3

                        # Create a external loadbalancer to point 3 pod deployment
                        $ kubectl expose deploy lb-nginx --name=nginx-service --type=LoadBalancer --port=80 --dry-run=client -o yaml > nginx-service.yaml
                    </code></pre>
                    <strong>Q12. Create a horizontal autoscaling group</strong>
                    <p>
                        Create a horizontal autoscaling group that should start with 2 pods and scale when CPU usage is
                        over 50%.
                    </p>
                    <pre><code>Not in Syllabus</code></pre>
                    <strong>Q13. Create pods with restricted resource usage</strong>
                    <ol>
                        <li>Create a pods that has a CPU limit of 2 and should request 0.5 CPU when started.</li>
                        <li>Limit the memory usage for one of the pod to 100Mb.</li>
                    </ol>
                    <pre><code>
$ kubectl run nginx --image nginx --requests=cpu=.5,memory=100 --limits=cpu=2,memory=100

apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    resources:
      limits:
        cpu: "2"
        memory: "100"
      requests:
        cpu: 500m
        memory: "100"
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
                    </code></pre>
                    <strong>Q14. Create an init container</strong>
                    <p>
                        Create a nginx pod with an init container that populates the webroot of nginx pod with the
                        homepage of <i>Kubernauts.io</i>
                    </p>
                    <pre><code>
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox:1.28
    command: ['sh', '-c', 'echo The app is running! && sleep 3600']
  initContainers:
  - name: init-myservice
    image: busybox:1.28
    command: ['sh', '-c', "until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done"]
  - name: init-mydb
    image: busybox:1.28
    command: ['sh', '-c', "until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done"]
                    </code></pre>
                    <strong>Q15. Create a pod with specific UID</strong>
                    <p>
                        Create a pod that runs all processes as user 1000.
                    </p>
                    <pre><code>
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: sc-nginx
  name: sc-nginx
spec:
  securityContext:
    runAsUser: 1000
  containers:
  - image: nginx
    name: sc-nginx
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
                    </code></pre>
                    <strong>Q16. Create a namespace</strong>
                    <ol>
                        <li>Run a pod in the new namespace.</li>
                        <li>Put memory limits on the namespace.</li>
                        <li>Limit pods to 2 persistent volumes in this namespace.</li>
                    </ol>
                    <pre><code>
# create a namespace
$ kubectl create ns default-nd

# set limits
apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-limit-range
spec:
  limits:
  - default:
      cpu: 1
    defaultRequest:
      cpu: 0.5
    type: Container

# Limit pods to 2 persistent volumes in this namespace
Not in Scope
                    </code></pre>
                    <strong>Q17. Write an ingress rule that redirects calls to /foo to one service and to /bar to
                        another</strong>
                    <strong>Q18. Write a service that exposes nginx on a nodeport</strong>
                    <ol>
                        <li>Change it to use a cluster port.</li>
                        <li>Scale the service.</li>
                        <li>Change it to use an external IP.</li>
                        <li>Change it to use a load balancer.</li>
                    </ol>
                    <pre>
    <code>
# Create a service for nginx pod on nodeport
$ kubectl expose po nginx --name=nginx-expose --type=NodePort --port=80

# Scale the service
Not Understand
    </code>
</pre>
                    <strong>Q19. Backup the etcd database</strong>
                    <ol>
                        <li>Backup the etcd database at <i>/opt/baks/etcd0001/ .</i></li>
                    </ol>
                    <pre><code>
$ ETCDCTL_API=3 etcdctl --endpoints=https://[127.0.0.1]:2379 \
                        --cacert=/etc/kubernetes/pki/etcd/ca.crt \
                        --cert=/etc/kubernetes/pki/etcd/server.crt \
                        --key=/etc/kubernetes/pki/etcd/server.key \
                        snapshot save /tmp/snapshot-pre-boot.db
                    </code></pre>
                    <strong>Q20. Create a networking policy such that only pods with the label access=granted can talk
                        to it</strong>
                    <ol>
                        <li>Create an nginx pod and attach this policy to it.</li>
                        <li>Create a busybox pod and attempt to talk to nginx - should be blocked.</li>
                        <li>Attach the label to busybox and try again - should be allowed.</li>
                    </ol>
                    <strong>Q21. Enable certificate rotation for the cluster.</strong> <br>
                    <strong>Q22. Create 2 pod definitions.</strong> <br>
                    Create 2 pod definitions with following features:
                    <ol>
                        <li>The first pod should be called master and second pod should be called sidecar.</li>
                        <li>The second pod should be scheduled to run anywhere the first pod is running i.e. The 2nd pod
                            should run alongside the first pod on the same node.
                        </li>
                    </ol>
                    <strong>Q23. Debug pod failure</strong> <br>
                    Deploy a pod using <a
                        href="https://github.com/kubernetes/website/blob/master/content/en/docs/tasks/debug-application-cluster/termination.yaml">this
                    manifest</a>.
                    <ol>
                        <li>Monitor the pod's deployment status.</li>
                        <li>Debug the cause of pod failure.</li>
                        <li>Customize the termination message as per your liking.</li>
                    </ol>
                    <strong>Q24. Audit the cluster</strong>
                    <p>
                        Audit the whole cluster to determine the cluster health and activities.
                    </p>
                    <pre><code>
                        Node in Scope
                    </code></pre>
                </div>
                <div id="question-2">
                    <h4 style="color: green;">Question Set 2:</h4>
                    <div>
                        <strong>Q1. Create a initContainers</strong><br>
                        <p>With image busybox which will run fix time before nginx pod ready.</p>
                        <pre><code>
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: nginx
  name: nginx
spec:
  initContainers:
  - command:
    - sleep
    - "60"
    image: busybox
    name: busybox
  containers:
  - image: nginx
    name: nginx
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
                        </code></pre>
                    </div>
                    <div>
                        <strong>Q2. List all pod which using the service nginx-service.</strong><br>
                        <pre><code>
$ for i in $(kg svc --no-headers | awk '{print $7}'); do kg po -l $i; done
$ kg po --show-labels | grep -F -f <(kg svc --no-headers | awk '{print $7}')
</code></pre>
                    </div>
                    <div>
                        <strong>Q3. Add security context' capabilites on a container which will set date on
                            pod.</strong><br>
                        <pre><code>
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: sc-nginx
  name: sc-nginx
spec:
  containers:
  - image: nginx
    name: sc-nginx
    resources: {}
    securityContext:
      capabilities:
        add:
        - SYS_TIME
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
                        </code></pre>
                    </div>
                    <div>
                        <strong>Q4. Create a daemon service name nginx with proper tolleration.</strong><br>
                        <pre><code>
apiVersion: apps/v1
kind: DaemonSet
metadata:
  labels:
    app: ds-nginx
  name: ds-nginx
spec:
  selector:
    matchLabels:
      app: ds-nginx
  template:
    metadata:
      labels:
        app: ds-nginx
    spec:
      containers:
      - image: nginx
        name: nginx
      tolerations:
      - key: 'node-role.kubernetes.io/master'
        operator: 'Exists'
                        </code></pre>
                    </div>
                    <div>
                        <strong>Q5. Create a new deployment named 'red' with the NGINX image and 3 replicas, and ensure
                            it gets placed on the master node only. Use the right operator.</strong>
                        <pre>
                            <code>
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: ds-nginx
  name: ds-nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ds-nginx
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: ds-nginx
    spec:
      containers:
      - image: nginx
        name: nginx
        resources: {}
      tolerations:
      - key: 'node-role.kubernetes.io/master'
        operator: 'Exists'
                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q6. Create a pod with selected any of the images. Image name redis,nginx</strong>
                        <pre>
                            <code>
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: redis
  name: redis
spec:
  containers:
  - image: redis
    name: redis
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q7. Create deployment with name deploy-nginx which accept traffic with service
                            service-nginx.</strong>
                        <pre>
                            <code>
$ kcd deploy dp-nginx --image nginx
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: dp-nginx
  name: dp-nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dp-nginx
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: dp-nginx
    spec:
      containers:
      - image: nginx
        name: nginx
        resources: {}
status: {}

# create service
$ k expose deploy dp-nginx --type=ClusterIP --name=dp-service --port=80 --dry-run=client -o yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app: dp-nginx
  name: dp-service
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: dp-nginx
  type: ClusterIP
status:
  loadBalancer: {}

                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q8. Get all the cluster users and write in a filename /var/answer/UJDHH.TXT</strong>
                        <pre>
                            <code>
$ k config view -o jsonpath='{.users[*].name}' > /var/UJDHH.TXT
                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q9. Create a secret with name env-secret with value password=user1 and use it in pod
                            envFrom.</strong>
                        <pre>
                            <code>
# Create a secret
$ kc secret generic env-secret --from-literal=password=user1 --dry-run=client -o yaml
apiVersion: v1
data:
  password: dXNlcjE=
kind: Secret
metadata:
  creationTimestamp: null
  name: env-secret

# Consume secret in envFrom  in  a pod nginx
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: secret-nginx
  name: secret-nginx
spec:
  containers:
  - image: nginx
    name: secret-nginx
    resources: {}
    envFrom:
    - secretRef:
        name: env-secret
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q10. To update a cluster we need to take the node down. Down the K82 .</strong>
                        <pre>
                            <code>
$ kubectl drain node K82
                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q11. Take a ETCD cluster backup on location /tmp/cluster.bk. All the required values
                            given.</strong>
                        <pre>
                            <code>
$ ETCDCTL_API=3 etcdctl --endpoints=https://[127.0.0.1]:2379 \
                        --cacert=/etc/kubernetes/pki/etcd/ca.crt \
                        --cert=/etc/kubernetes/pki/etcd/server.crt \
                        --key=/etc/kubernetes/pki/etcd/server.key \
                        snapshot save /tmp/cluster.bk
                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q12. A pod deployed cluster-pod in the system. Create a service cluster-service in
                            which POD will be access.</strong>
                        <pre>
                            <code>
$ kcd service clusterip cluster-service --tcp=80:8080
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app: cluster-service
  name: cluster-service
spec:
  ports:
  - name: 80-8080
    port: 80
    protocol: TCP
    targetPort: 8080
  selector:
    app: cluster-service
  type: ClusterIP
status:
  loadBalancer: {}
                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q13. Create a egress rule to a pod egress-pod where ip does not need to mention.</strong>
                        <pre>
                            <code>

                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q14. Write dns information to the file /var/answer/HDKDKD.txt from the pod
                            log-pod.</strong>
                        <pre>
                            <code>

                            </code>
                        </pre>
                    </div>
                    <div><strong>Q15. Schedul a pod nginx-pod with image nginx in node k82 in namespace
                        cluster-scheduler.</strong>
                        <pre>
                            <code>

                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q16. Set labels with proper information ???</strong>
                        <pre>
                            <code>

                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q17. Create a deployment with image nginx and name will be dep-nginx. Upgrade the image
                            of the deployment nginx-12.04. After proper upgrade backto the previous version of the image
                            nginx.</strong>
                        <pre>
                            <code>

                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q18. Add a ConfigMap password with configuring in volume. ConfigMap value is
                            APP_COLOR=RED and volume name is color-volume.</strong>
                        <pre>
                            <code>

                            </code>
                        </pre>
                    </div>
                    <div>
                        <strong>Q19. Create a volume pv-log with empty with claim name pvc-log and mount in pod redis
                            with image redis.</strong>
                        <pre>
                            <code>

                            </code>
                        </pre>
                    </div>
                </div>
                <div id="question-3">
                    <h4 style="color: green;">Question Set 3:</h4>
                    <strong>Q1. Create a pod named “web” using image nginx:1.11.9-alpine, on ports 80 and
                        443</strong><br>
                    <pre><code>
# Command
$ kubectl run web --image=nginx:1.11.9-alpine --port=80 --dry-run=client -o yaml > web.yaml

# Output
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: web
  name: web
spec:
  containers:
  - image: nginx:1.11.9-alpine
    name: web
    ports:
    - containerPort: 80
    - containerPort: 443
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
                    </code></pre>
                    <strong>Q2. Create a service to expose that pod, named as “webservice”</strong><br>
                    <pre><code>
# Command
$ kubectl expose pod web --name=webservice --type=ClusterIP
# Output
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    run: web
  name: webservice
spec:
  ports:
  - name: port-1
    port: 80
    protocol: TCP
    targetPort: 80
  - name: port-2
    port: 443
    protocol: TCP
    targetPort: 443
  selector:
    run: web
  type: ClusterIP
status:
  loadBalancer: {}
                    </code></pre>
                    <strong>Q3. Copy the dns records for the service in file /opt/web.dnsrecord
                    </strong><br>
                    <strong>Q4. Create a deployment with “redis” image on port 6379 and expose a service.</strong><br>
                    <pre><code>
# Command
$ kubectl create deploy redis-dp --image redis --dry-run=client -o yaml > redis-dp.yaml

# Output
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: redis-dp
  name: redis-dp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis-dp
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: redis-dp
    spec:
      containers:
      - image: redis
        name: redis
        resources: {}
status: {}
                    </code></pre>
                    <strong>Q5. Increase the number of replicas to 3</strong><br>
                    <pre><code>$ kubectl scale deploy redis-dp --replicas=3</code></pre>
                    <strong>Q6. Perform a rolling update to version 4.0.11-alpine.</strong><br>
                    <pre><code>$ kubectl set image deploy redis-dp redis=redis:4.0.11-alpine --record=True</code></pre>
                    <strong>Q7. Copy pod spec to file /opt/yournamespace/podversion.</strong><br>
                    <pre><code>$ kubectl get deploy redis-dp -o yaml > /opt/yournamespace/podversion</code></pre>
                    <strong>Q8. Undo the image update to redis.. and confirm pod spec image matches</strong><br>
                    <pre><code>$ kubectl rollout undo deploy redis-dp</code></pre>
                    <strong>Q9. Create a multi container pod, with redis, memcached, nginx and mysql, assign resource
                        memory limit as 250M for each container.</strong><br>
                    <pre><code>apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: multicont
  name: multicont
spec:
  containers:
  - image: redis
    name: multicont
    resources:
      limits:
        memory: 250Mi
  - image: memcached
    name: memcached
    resources:
      limits:
        memory: 250Mi
  - image: nginx
    name: nginx
    resources:
      limits:
        memory: 250Mi
  - image: mysql
    name: mysql
    resources:
      limits:
        memory: 250Mi
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}</code></pre>
                    <strong>Q10. List all the pods in your namespace sorted by name.</strong><br>
                    <pre><code>$ kubectl get po --sort-by=.metadata.name</code></pre>
                    <strong>Q10. List all the pods in your namespace sorted by name at directory “/export/volume” and
                        Copy the pod spec into /opt/yourname/shellvolume</strong><br>
                    <pre><code>
                        $ kubectl get po --sort-by=.metadata.name > /export/volume
                        $ kubectl get po -o yaml > /opt/yourname/shellvolume
                    </code></pre>
                    <strong>Q12. To the earlier pod “shell” attach liveliness probe to check the file
                        /export/volume/app.log being available.</strong><br>
                    <pre><code>
                        
                    </code></pre>
                    <strong>Q13. Setup init container into shell pod that got created just now, to create a file
                        /export/volume/app.log empty file before the busybox container is run.</strong><br>
                    <strong>Q14. Create a secret “myctl-secret” with user=myctl, secret=”SOMESECRET” edit the “shell”
                        pod to have the above secret imported as a volume at /opt/mysecretvolume, and MYSECRET
                        environment defined to map to key secret in “myctl-secret”
                    </strong><br>
                    <strong>Q15. Create a persistent Volume named “myctl” specification that defines a volume for 10Gi
                        mapping to hostpath /opt/myctl
                    </strong><br>
                    <strong>Q16. Take the etcd database snapshot saved into file /opt/myctl/etcd snapshotthe
                        certificates and keys are available in /opt/certs directory.
                    </strong><br>
                    <strong>Q17. Get the dns records for the service and pods for the deployment “redis”
                        copied to file /opt/myctl/dnsrecord.redis
                    </strong><br>
                    <strong>Q18. List all the pods that are serviced by the service “webservice”and copy the output in
                        /opt/myctl/webservice.targets
                    </strong><br>
                </div>
                <div id="question-4">
                    <h4 style="color: green;">Question Set 4:</h4>
                    <strong>Q1. Create a pod redis version 5.0-rc4-alpine named “mycache”</strong><br>
                    <strong>Q2. Upgrade the pod to use 5.0-rc-alpine and save the pod spec as p2
                        along with the command used.</strong><br>
                    <strong>Q3. Create a config map from file /var/lib/kubelet/config.yaml
                        and create a nginx pod that sees the configmap as a volume in the same path within the
                        container,
                        assign port 80 and expose it as a service “webservice” as well. The pod should be named
                        “web”</strong><br>
                    <strong>Q4. Create a busybox container that sleeps 60000, named “mybox”.</strong><br>
                    <strong>Q5. Attach liveness probe to the container and restart if environment USER is null or
                        undefined.
                        Report pod status after attaching liveness probe.</strong><br>
                    <strong>Q6. Pass ENV variables “USER” and “SECRET”
                        from a secret “boxsecret” defined already that has these initialized as
                        “bob”/”somesupersecret”</strong><br>
                    <strong>Q7. Attach resource requests and limits for cpu and memory at 10m/10m and 100m/1000M
                        for “mybox” pod above.</strong><br>
                    <strong>Q8. Create a pv named “yourname-volume” that maps to hostpath “/opt/volume/yourname/” as
                        100G capacity, and
                        policy reclaim.</strong><br>
                    <strong>Q9. Create a deployment “myvolume” for memcached that get a 1G volume mapped from
                        yourname-volume at /opt/myvolume</strong><br>
                    <strong>Q10. Scale the deployment to have 2 replicas.</strong><br>
                    <strong>Q11. Update myvolume deployment to have 1.5.10-alpine image on all replicas.</strong><br>
                    <strong>Q12. Setup a init container in myvolume deployment to init a file in the mapped volume
                        /opt/myvolume/config.yaml before the real memcached kick starts.</strong><br>
                    <strong>Q13. Monitor pod lifecycle and log messages when pod/container starts/stops.</strong><br>
                    <strong>Q14. Create a multi-container pod with nginx, memcached, redis all sharing the volume mount
                        at /opt/myvolume with a 1G claim from your earlier pv created.</strong><br>
                    <strong>Q15. List all objects in your namespace that has label “ques=p5”
                        Find all pods that are serviced by your webservice.</strong><br>
                </div>
                <div id="question-5">
                    <h4 style="color: green;">Question Set 5:</h4>
                    <strong>Q1. Create a node that has a SSD and label it as such.</strong><br>
                    <strong>Q2. Create a pod that is only scheduled on SSD nodes. </strong><br>
                    <strong>Q3. Create 2 pod definitions: the second pod should be scheduled to run anywhere the first
                        pod
                        is running — 2nd pod runs alongside the first pod.</strong><br>
                    <strong>Q4. Create a deployment running nginx version 1.12.2 that will run in 2 pods</strong><br>
                    <p>
                        a. Scale this to 4 pods.
                        b. Scale it back to 2 pods.
                        c. Upgrade this to 1.13.8
                        d. Check the status of the upgrade
                        e. How do you do this in a way that you can see history of what happened?
                        f. Undo the upgrade
                    </p>
                    <strong>Q5. Create a service that uses a scratch disk.</strong><br>
                    <p>
                        a. Change the service to mount a disk from the host.
                        b. Change the service to mount a persistent volume.
                    </p>
                    <strong>Q6. Create a pod that has a liveness check</strong><br>
                    <strong>Q7. Create a service that manually requires endpoint creation — and create that
                        too</strong><br>
                    <strong>Q8. Create a daemon set
                        a. Change the update strategy to do a rolling update but delaying 30 seconds between pod
                        updates</strong><br>
                    <strong>Q9. Create a static pod</strong><br>
                    <strong>Q10. Create a busybox container without a manifest. Then edit the manifest.</strong><br>
                    <strong>Q11. Create a pod that uses secrets</strong><br>
                    <p>
                        a. Pull secrets from environment variables
                        b. Pull secrets from a volume
                        c. Dump the secrets out via kubectl to show it worked
                    </p>
                    <strong>Q12. Create a job that runs every 3 minutes and prints out the current time.</strong><br>
                    <strong>Q13. Create a job that runs 20 times, 5 containers at a time, and prints “Hello parallel
                        world”</strong><br>
                    <strong>Q14. Create a service that uses an external load balancer and points to a 3 pod cluster
                        running
                        nginx.</strong><br>
                    <strong>Q15. Create a horizontal autoscaling group that starts with 2 pods and scales when CPU usage
                        is
                        over 50%.</strong><br>
                    <strong>Q16. Create a custom resource definition</strong><br>
                    <p>a. Display it in the API with curl</p>
                    <strong>Q17. Create a networking policy such that only pods with the label access=granted can talk
                        to
                        it.</strong><br>
                    <p>a. Create an nginx pod and attach this policy to it.
                        b. Create a busybox pod and attempt to talk to nginx — should be blocked
                        c. Attach the label to busybox and try again — should be allowed</p>
                    <strong>Q18. Create a service that references an externalname.</strong><br>
                    <p>a. Test that this works from another pod</p>
                    <strong>Q19. Create a pod that runs all processes as user 1000.</strong><br>
                    <strong>Q20. Create a namespace</strong><br>
                    <p>a. Run a pod in the new namespace
                        b. Put memory limits on the namespace
                        c. Limit pods to 2 persistent volumes in this namespace</p>
                    <strong>Q21. Write an ingress rule that redirects calls to /foo to one service and to /bar to
                        another</strong><br>
                    <strong>Q22. Write a service that exposes nginx on a nodeport</strong><br>
                    <p>a. Change it to use a cluster port
                        b. Scale the service
                        c. Change it to use an external IP
                        d. Change it to use a load balancer</p>
                    <strong>Q23. Deploy nginx with 3 replicas and then expose a port</strong><br>
                    <p>a. Use port forwarding to talk to a specific port</p>
                    <strong>Q24. Make an API call using CURL and proper certs</strong><br>
                    <strong>Q25. Upgrade a cluster with kubeadm</strong><br>
                    <strong>Q26. Get logs for a pod</strong><br>
                    <strong>Q27. Deploy a pod with the wrong image name (like — image=nginy) and find the error
                        message.</strong><br>
                    <strong>Q28. Get logs for kubectl</strong><br>
                    <strong>Q29. Get logs for the scheduler</strong><br>
                    <strong>Q30. Restart kubelet</strong><br>
                    <strong>Q31. Convert a CRT to a PEM</strong><br>
                    <p>a. Convert it back</p>
                    <strong>Q32. Backup an etcd cluster</strong><br>
                    <strong>Q33. List the members of an etcd cluster</strong><br>
                    <strong>Q34 Find the health of etcd</strong><br>
                </div>
            </div>
        </div>
    </article>
</div>

<footer class="footer text-center py-2 theme-bg-dark">
    <small class="copyright"> © 2020 by Mehedi Hasan | Powered by GitHub pages</small>
</footer>

<!-- Javascript -->
<script src="../assets/plugins/jquery-3.4.1.min.js"></script>
<script src="../assets/plugins/popper.min.js"></script>
<script src="../assets/plugins/bootstrap/js/bootstrap.min.js"></script>

<!-- Page Specific JS -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>

<!-- Custom JS -->
<script src="../assets/js/blog.js"></script>

<!-- Style Switcher (REMOVE ON YOUR PRODUCTION SITE) -->
<script src="../assets/js/demo/style-switcher.js"></script>


</body>
</html> 

