<!DOCTYPE html>
<html lang="en">
<head>
    <title>swapon - Kubernetes Commands for Resource Generation</title>

    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Blog Template">
    <meta name="author" content="Xiaoying Riley at 3rd Wave Media">
    <link rel="shortcut icon" href="favicon.ico">

    <!-- FontAwesome JS-->
    <script defer src="../assets/fontawesome/js/all.min.js"></script>

    <!-- Plugin CSS -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/monokai-sublime.min.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="../assets/css/theme-1.css">


</head>

<body>

<header class="header text-center">
    <h1 class="blog-name pt-lg-4 mb-0"><a href="../index.html">Mehedi Hasan</a></h1>

    <nav class="navbar navbar-expand-lg navbar-dark">

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navigation"
                aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div id="navigation" class="collapse navbar-collapse flex-column">
            <div class="profile-section pt-3 pt-lg-0">
                <img class="profile-image mb-3 rounded-circle mx-auto" src="../assets/images/profile.jpg" alt="image">

                <div class="bio mb-3">Hi, my name is Md. Mehedi Hasan. Briefly introduce yourself here. You can also
                    provide a link to the about page.
                </div>
                <!--//bio-->
                <ul class="social-list list-inline py-3 mx-auto">
                    <li class="list-inline-item"><a target="_blank" href="https://www.linkedin.com/in/nopaws/"><i
                            class="fab fa-linkedin-in fa-fw"></i></a></li>
                    <li class="list-inline-item"><a target="_blank" href="https://github.com/gitmehedi"><i
                            class="fab fa-github-alt fa-fw"></i></a></li>
                    <li class="list-inline-item"><a target="_blank" href="https://stackoverflow.com/cv/mdmehedi"><i
                            class="fab fa-stack-overflow fa-fw"></i></a></li>
                </ul><!--//social-list-->
                <hr>
            </div><!--//profile-section-->

            <ul class="navbar-nav flex-column text-left">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html"><i class="fas fa-home fa-fw mr-2"></i>Home <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../about.html"><i class="fas fa-user fa-fw mr-2"></i>About Me</a>
                </li>
            </ul>
        </div>
    </nav>
</header>


<div class="main-wrapper">
    <article class="blog-post px-3 py-5 p-md-5">
        <div class="container">
            <header class="blog-post-header">
                <h2 class="title mb-2">Kubernetes Commands for Resource Generation</h2>
                <div class="meta mb-3">
                    <span class="date">Published on 18/06/2020</span>
                    <span class="time">5 min read</span>
                </div>
            </header>

            <div class="blog-post-body">
                <figure class="blog-banner" style="text-align: center;">
                    <img class="img-fluid" src="../assets/images/blog/kubernetes_command.png" alt="image">
                </figure>
                <p>In kubernetes, command can be divided into two categories depending on how command generate
                    resources. Both categories are used depending on resource generation requirements.</p>
                <ol>
                    <li>Declarative Approach</li>
                    <li>Imperative Approach</li>
                </ol>

                <h3 class="mt-5 mb-3">1. Declarative Approach</h3>
                Declarative approach used when a definition file needed to declare and using that file kubernetes
                generate in the cluster.
                Two steps follow to accomplish in declarative approach.
                <ol>
                    <li>Create a definition file</li>
                    <li>Use command to generate the resources</li>
                </ol>
                <pre>
                    <code>
# 1. define a definition file nginx-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  minReadySeconds: 5
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80

# 2. create resources using definition file nginx-deployment.yaml
$ kubectl create -f nginx-deployment.yaml
                    </code>
                </pre>
                <h3 class="mt-5 mb-3">2. Imperative Approach</h3>
                Imperative approach is the way resource can be created using command line instruction without defining
                any resource. Limited resource can be created using imperative command. In fact all the allowed resource
                does not create with all properties. But imperative command is very helpful for faster your work
                process. Additional properties can be added using after generation of definition file from imperative
                command. Command are used for imperative command.
                <pre>
                    <code>
$ kubectl run
$ kubectl create
                    </code>
                </pre>
                Imperative command supports total 16 resource generation.
                <ul>
                    <li>Kubectl Run: 1</li>
                    <li>Kubectl Create: 15</li>
                </ul>
                <strong>KUBECTL RUN supports only 1 resource.</strong>
                <pre>
                    <code>$ kubectl run front-end --image=nginx --port=80</code>
                </pre>

                <h4>Details</h4>
                <pre>
                    <code>
Examples:
  # Start a hazelcast pod and set environment variables "DNS_DOMAIN=cluster" and "POD_NAMESPACE=default" in thecontainer.
  kubectl run hazelcast --image=hazelcast/hazelcast --env="DNS_DOMAIN=cluster" --env="POD_NAMESPACE=default" --port=5701 --labels="app=hazelcast,env=prod"

  # Start a nginx pod, but overload the spec with a partial set of values parsed from JSON.
  kubectl run nginx --image=nginx --overrides='{ "apiVersion": "v1", "spec": { ... } }'

  # Start the nginx pod using the default command, but use custom arguments (arg1 .. argN) for that command.
  kubectl run nginx --image=nginx -- <arg1> <arg2> ... <argN>

  # Start the nginx pod using a different command and custom arguments.
  kubectl run nginx --image=nginx --command -- <cmd> <arg1> ... <argN>

Options:
  --command=false: If true and extra arguments are present, use them as the 'command' field in the container, rather than the 'args' field which is the default.
  --env=[]: Environment variables to set in the container.
  --expose=false: If true, service is created for the container(s) which are run
  --hostport=-1: The host port mapping for the container port. To demonstrate a single-machine container.
  --image='': The image for the container to run.
  --image-pull-policy='': The image pull policy for the container. If left empty, this value will not be specified by the client and defaulted by the server
  -l, --labels='': Comma separated labels to apply to the pod(s). Will override previous values.
  --limits='': The resource requirement limits for this container.  For example, 'cpu=200m,memory=512Mi'.  Note that server side components may assign limits depending on the server configuration, such as limit ranges.
  --port='': The port that this container exposes.
  --record=false: Record current kubectl command in the resource annotation. If set to false, do not record the command. If set to true, record the command. If not set, default to updating the existing annotation value only if one already exists.
  --requests='': The resource requirement requests for this container.  For example, 'cpu=100m,memory=256Mi'.  Note that server side components may assign requests depending on the server configuration, such as limit ranges.
  --rm=false: If true, delete resources created in this command for attached containers.
  --serviceaccount='': Service account to set in the pod spec.
                    </code>
                </pre>

                <strong>KUBECTL CREATE supports 15 resources</strong>
                <pre>
                    <code>

  clusterrole         Create a ClusterRole.
  clusterrolebinding  Create a ClusterRoleBinding for a particular ClusterRole
  configmap           Create a configmap from a local file, directory or literal value
  cronjob             Create a cronjob with the specified name.
  deployment          Create a deployment with the specified name.
  job                 Create a job with the specified name.
  namespace           Create a namespace with the specified name
  poddisruptionbudget Create a pod disruption budget with the specified name.
  priorityclass       Create a priorityclass with the specified name.
  quota               Create a quota with the specified name.
  role                Create a role with single rule.
  rolebinding         Create a RoleBinding for a particular Role or ClusterRole
  secret              Create a secret using specified subcommand
  service             Create a service using specified subcommand.
  serviceaccount      Create a service account with the specified name
                    </code>
                </pre>
                <h4>Usage of imperative commands</h4>
                <h5>ClusterRole</h5>
                <pre>
                    <code>
Examples:
  # Create a ClusterRole named "pod-reader" that allows user to perform "get", "watch" and "list" on pods
  kubectl create clusterrole pod-reader --verb=get,list,watch --resource=pods

  # Create a ClusterRole named "pod-reader" with ResourceName specified
  kubectl create clusterrole pod-reader --verb=get --resource=pods --resource-name=readablepod
--resource-name=anotherpod

  # Create a ClusterRole named "foo" with API Group specified
  kubectl create clusterrole foo --verb=get,list,watch --resource=rs.extensions

  # Create a ClusterRole named "foo" with SubResource specified
  kubectl create clusterrole foo --verb=get,list,watch --resource=pods,pods/status

  # Create a ClusterRole name "foo" with NonResourceURL specified
  kubectl create clusterrole "foo" --verb=get --non-resource-url=/logs/*

  # Create a ClusterRole name "monitoring" with AggregationRule specified
  kubectl create clusterrole monitoring --aggregation-rule="rbac.example.com/aggregate-to-monitoring=true"

Options:
   --non-resource-url=[]: A partial url that user should have access to.
   --resource=[]: Resource that the rule applies to
   --resource-name=[]: Resource in the white list that the rule applies to, repeat this flag for multiple items
   --verb=[]: Verb that applies to the resources contained in the rule

Usage:
  kubectl create clusterrole NAME --verb=verb --resource=resource.group [--resource-name=resourcename]
[--dry-run=server|client|none] [options]
                    </code>
                </pre>
                <h5>ClusterRole</h5>
                <pre>
                    <code>
Create a ClusterRoleBinding for a particular ClusterRole.

Examples:
  # Create a ClusterRoleBinding for user1, user2, and group1 using the cluster-admin ClusterRole
  kubectl create clusterrolebinding cluster-admin --clusterrole=cluster-admin --user=user1 --user=user2 --group=group1

Options:
  --clusterrole='': ClusterRole this ClusterRoleBinding should reference
  --group=[]: Groups to bind to the clusterrole
  --serviceaccount=[]: Service accounts to bind to the clusterrole, in the format <namespace>:<name>

Usage:
  kubectl create clusterrolebinding NAME --clusterrole=NAME [--user=username] [--group=groupname]
[--serviceaccount=namespace:serviceaccountname] [--dry-run=server|client|none] [options]

                    </code>
                </pre>

                <h5>ClusterRole</h5>
                <pre>
                    <code>
Create a configmap based on a file, directory, or specified literal value.

A single configmap may package one or more key/value pairs.

When creating a configmap based on a file, the key will default to the basename of the file, and the value will default
to the file content.  If the basename is an invalid key, you may specify an alternate key.

When creating a configmap based on a directory, each file whose basename is a valid key in the directory will be
packaged into the configmap.  Any directory entries except regular files are ignored (e.g. subdirectories, symlinks,
devices, pipes, etc).

Aliases:
configmap, cm

Examples:
  # Create a new configmap named my-config based on folder bar
  kubectl create configmap my-config --from-file=path/to/bar

  # Create a new configmap named my-config with specified keys instead of file basenames on disk
  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt

  # Create a new configmap named my-config with key1=config1 and key2=config2
  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2

  # Create a new configmap named my-config from the key=value pairs in the file
  kubectl create configmap my-config --from-file=path/to/bar

  # Create a new configmap named my-config from an env file
  kubectl create configmap my-config --from-env-file=path/to/bar.env

Options:
   --from-env-file='': Specify the path to a file to read lines of key=val pairs to create a configmap (i.e. a Docker.env file).
   --from-file=[]: Key file can be specified using its file path, in which case file basename will be used as configmap key, or optionally with a key and file path, in which case the given key will be used.  Specifying a directory will iterate each named file in the directory whose basename is a valid configmap key.
   --from-literal=[]: Specify a key and literal value to insert in configmap (i.e. mykey=somevalue)

Usage:
  kubectl create configmap NAME [--from-file=[key=]source] [--from-literal=key1=value1] [--dry-run=server|client|none]
[options]
                    </code>
                </pre>

                <h5>cronjob</h5>
                <pre>
                    <code>

                    </code>
                </pre>
                <h5>deployment</h5>
                <pre>
                    <code>

                    </code>
                </pre>
                <h5>namespace</h5>
                <pre>
                    <code>

                    </code>
                </pre>
                <h5>poddisruptionbudget</h5>
                <pre>
                    <code>

                    </code>
                </pre>
                <h5>priorityclass</h5>
                <pre>
                    <code>

                    </code>
                </pre>
                <h5>quota</h5>
                <pre>
                    <code>

                    </code>
                </pre>
                <h5>role</h5>
                <pre>
                    <code>

                    </code>
                </pre>
                <h5>rolebinding</h5>
                <pre>
                    <code>

                    </code>
                </pre>
                <h5>secret</h5>
                <pre>
                    <code>

                    </code>
                </pre>
                <h5>service</h5>
                <pre>
                    <code>

                    </code>
                </pre>
                <h5>serviceaccount</h5>
                <pre>
                    <code>

                    </code>
                </pre>






                <h3 class="mt-5 mb-3">Necessary Kubernetes Command for Alias</h3>
                <pre>
                       <code>

$ alias k="kubectl"
$ alias kn="kubectl get nodes -o wide"
$ alias kp="kubectl get pods -o wide"
$ alias kd="kubectl get deployment -o wide"
$ alias ks="kubectl get svc -o wide"


$ alias ke="kubectl explain --recursive"
$ alias kdp="kubectl describe pod"
$ alias kdd="kubectl describe deployment"
$ alias kds="kubectl describe service"
$ alias kdn="kubectl describe node"
$ alias kcr="kubectl run --dry-run=client -o yaml --generator=run-pod/v1"
$ alias kcc="kubectl create --dry-run=client -o yaml"

$ alias k="kubectl" kg="kubectl get -o wide" kd="kubectl describe" kdl="kubectl delete" krd="kubectl run --dry-run=client -o yaml" kcd="kubectl create --dry-run=client -o yaml" kc="kubectl create" kx="kubectl explain --recursive"

					    </code>
				    </pre>


                <nav class="blog-nav nav nav-justified my-5">
                    <a class="nav-link-prev nav-item nav-link rounded-left" href="index.html">Previous<i
                            class="arrow-prev fas fa-long-arrow-alt-left"></i></a>
                    <a class="nav-link-next nav-item nav-link rounded-right" href="blogs.html">Next<i
                            class="arrow-next fas fa-long-arrow-alt-right"></i></a>
                </nav>

            </div>
    </article>


    <footer class="footer text-center py-2 theme-bg-dark">
        <small class="copyright"> © 2020 by Mehedi Hasan | Powered by GitHub pages</small>
    </footer>
</div>


<!-- Javascript -->
<script src="../assets/plugins/jquery-3.4.1.min.js"></script>
<script src="../assets/plugins/popper.min.js"></script>
<script src="../assets/plugins/bootstrap/js/bootstrap.min.js"></script>

<!-- Page Specific JS -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>

<!-- Custom JS -->
<script src="../assets/js/blog.js"></script>

<!-- Style Switcher (REMOVE ON YOUR PRODUCTION SITE) -->
<script src="../assets/js/demo/style-switcher.js"></script>


</body>
</html> 

